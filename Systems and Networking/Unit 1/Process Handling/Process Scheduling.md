# Process Scheduling

A crucial job of the [Operating System](/Systems%20and%20Networking/Unit%201/Operating%20System/Operating%20System.md) is to keep the [CPU](/Systems%20and%20Networking/Unit%201/Architecture/CPU.md) busy at all time to maximize execution efficiency. Furthermore, it must execute [processes](/Systems%20and%20Networking/Unit%201/Operating%20System/Process.md) in such a way to deliver *acceptable* response times for all programs, particularly interactive ones.

The process scheduler must implement these objectives paying attention to any excessive overhead generated by swapping processes in and out of the CPU.

> [!warning] Overhead
> Overhead is the time used by doing *routine actions*, like *[context-switching](#Context%20Switch)*. Swapping processes in the CPU too frequently generates too much overhead, which could be used by processes ready for execution.

## Process State Queues

The [OS](/Systems%20and%20Networking/Unit%201/Operating%20System/Operating%20System.md) has a queue for each [process state](/Systems%20and%20Networking/Unit%201/Operating%20System/Process.md#Process%20Execution%20State), processes' [PCB](Systems%20and%20Networking/Unit%201/Operating%20System/Process.md#Process%20Control%20Block)'s are saved in the queue of the respective state. When the OS changes the status of a process, the process' PCB is moved from its previous queue to the queue of the current state.

> [!tip]
> This method to manage processes is very flexible, because the OS may use different (scheduling) policies to manage the processes in each queue.

![Ready Queuing Flow](/assets/ready_queue_flow.jpg)

Furthermore, the waiting queue may be subdivided into one queue for each [I/O device](/Systems%20and%20Networking/Unit%201/Architecture/IO%20Devices.md), so that processes wait in the queue of the device they're waiting for.

![Example of Process State Queues](/assets/process_state_queues.jpg)

## Process Scheduler

The process scheduler is that part of the [OS](/Systems%20and%20Networking/Unit%201/Operating%20System/Operating%20System.md) that decides which [processes](/Systems%20and%20Networking/Unit%201/Operating%20System/Process.md) to execute and when. Then, its job is to perform those actions needed to let the [CPU](Systems%20and%20Networking/Unit%201/Architecture/CPU.md) run the selected process (i.e. [context switch](#Context%20Switch)).

There are three types of scheduler:

| **Type**                | **Frequency**                                       | **Description / Advantages**                                                                               |
| ----------------------- | --------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| *Long-Term Scheduler*   | Infrequent                                          | Typical of batch/heavily loaded systems, it doesn't generate unnecessary overhead.                         |
| *Short-Term Scheduler*  | Very frequent                                       | Performs context switches frequently, decreases *response time* of processes at the cost of more overhead. |
| *Medium-Term Scheduler* | Frequency is proportional to the load of the system | Reduces overhead when there isn't a high load and allows small jobs to execute when there is a high load.  |

> [!tip] Efficient Scheduling
> An efficient scheduling system must mix CPU-bound and I/O-bound processes in such a way to execute CPU-bound processes when the I/O-bound ones are waiting. 

## Context Switch

Context Switch is the procedure used by the [CPU](/Systems%20and%20Networking/Unit%201/Architecture/CPU.md) to suspend a currently executing [process](/Systems%20and%20Networking/Unit%201/Operating%20System/Process.md) in order to run a ready one.

It's not a trivial operation, because when performing a context switch the CPU must:
1. Update the [PCB](/Systems%20and%20Networking/Unit%201/Operating%20System/Process.md#Process%20Control%20Block) of the current process with the internal state of the process;
2. Load the internal state of the ready process from the PCB to the CPU.

> [!info] Internal State
> The internal state of a process includes everything needed by the CPU to run the process, such as special registers (PC, SP, etc.) and ordinary registers.

A context switch may occur due to any incoming [trap](/Systems%20and%20Networking/Unit%201/Operating%20System/Trap.md) (i.e. system calls, exceptions, HW interrupts). Whenever this happens, the CPU must context-switch to [kernel mode](Systems%20and%20Networking/Unit%201/Operating%20System/Protection%20and%20Security.md#Kernel-User%20Mode) to handle the interrupt.

![Example of Context Switch](assets/context_switch.jpg)

### Timed Context Switch

To avoid CPU-bound processes from hogging the [CPU](/Systems%20and%20Networking/Unit%201/Architecture/CPU.md), [interrupts](/Systems%20and%20Networking/Unit%201/Operating%20System/Trap.md) may be triggered whenever a time slice has passed using a [timer](/Systems%20and%20Networking/Unit%201/Architecture/Timer.md). The **time slice** is defined as the maximum amount of time between two consecutive context switches.

Timed context-swtich is the mean through which **time-sharing multi-tasking** [OS](/Systems%20and%20Networking/Unit%201/Operating%20System/Operating%20System.md)'s can implement **pseudo-parallelism** (apparently run two or more processes at the same time).